---
alwaysApply: true
---

## 1. **SOLID Principles**

We follow the **SOLID** principles to ensure code that is maintainable, extensible, and robust.

- **Single Responsibility Principle (SRP)**  
  Each component/class should have **only one reason to change**.

  ‚úÖ Example:

  ```tsx
  // Good: Separate data fetching from UI
  interface IUserList {
    users: string[]
  }

  const UserList: React.FC<IUserList> = ({ users }) => (
    <ul>
      {users.map(user => (
        <li key={user}>{user}</li>
      ))}
    </ul>
  )
  ```

‚ùå Avoid:

```tsx
// Bad: Component fetches and renders in the same place
const UserList = () => {
  const [users, setUsers] = useState<string[]>([])
  useEffect(() => {
    fetch("/api/users")
      .then(res => res.json())
      .then(setUsers)
  }, [])
  return (
    <ul>
      {users.map(u => (
        <li>{u}</li>
      ))}
    </ul>
  )
}
```

- **Open/Closed Principle (OCP)**
  Code should be **open for extension, closed for modification**.

  ‚úÖ Example:

  ```ts
  interface IDiscount {
    apply(price: number): number
  }

  class PercentageDiscount implements IDiscount {
    constructor(private percent: number) {}
    apply(price: number) {
      return price * (1 - this.percent)
    }
  }

  class FixedDiscount implements IDiscount {
    constructor(private amount: number) {}
    apply(price: number) {
      return price - this.amount
    }
  }
  ```

- **Liskov Substitution Principle (LSP)**
  Subtypes must be substitutable for their base types.

  ‚úÖ Example:

  ```ts
  const discounts: IDiscount[] = [new PercentageDiscount(0.1), new FixedDiscount(20)]

  discounts.forEach(d => console.log(d.apply(100)))
  ```

- **Interface Segregation Principle (ISP)**
  No component should depend on methods it doesn‚Äôt use.

  ‚úÖ Example:

  ```ts
  interface IClickable {
    onClick(): void
  }

  interface IHoverable {
    onHover(): void
  }
  ```

- **Dependency Inversion Principle (DIP)**
  Depend on **abstractions, not concretions**.

  ‚úÖ Example:

  ```ts
  class PaymentProcessor {
    constructor(private discount: IDiscount) {}
    checkout(price: number) {
      return this.discount.apply(price)
    }
  }
  ```

---

## 2. **Clean Code Paradigms**

- Code should be **self-explanatory** without excessive comments.
- Use **meaningful names** and **small, focused functions**.

‚úÖ Example:

```ts
// Good: Clear and simple
const calculateFinalPrice = (price: number, discount: IDiscount) => discount.apply(price)
```

‚ùå Example:

```ts
// Bad: Unclear, misleading variable names
const x = (a: number, b: any) => b.apply(a)
```

---

## 3. **Composition Over Inheritance**

Prefer **composing small reusable components** rather than extending classes.

‚úÖ Example:

```tsx
const WithLoading = ({ isLoading, children }: { isLoading: boolean; children: React.ReactNode }) => {
  return isLoading ? <Spinner /> : <>{children}</>
}

const UserPage = () => (
  <WithLoading isLoading={false}>
    <UserList users={["Alice", "Bob"]} />
  </WithLoading>
)
```

‚ùå Example:

```ts
// Bad: Inheriting when not necessary
class LoadingUserList extends UserList {
  isLoading = true
}
```

---

## 4. **Type Safety**

- All components and logic must be **strongly typed**.
- Component props should be defined with `I*` interfaces.

‚úÖ Example:

```tsx
interface IMyComponent {
  title: string
  count?: number
}

const MyComponent: React.FC<IMyComponent> = ({ title, count = 0 }) => (
  <h1>
    {title} ({count})
  </h1>
)
```

---

## 5. **Testing**

- Always write tests for **functionality**, not UI rendering details.
- Focus on business logic, state changes, and interactions.

‚úÖ Example:

```ts
test("PercentageDiscount applies correctly", () => {
  const discount = new PercentageDiscount(0.2)
  expect(discount.apply(100)).toBe(80)
})
```

‚ùå Avoid:

```ts
// Bad: Testing HTML structure too tightly
expect(screen.getByText("Alice")).toBeInTheDocument()
```

---

## 6. **Performance Optimizations**

- After implementing logic, make a round of **optimizations**.
- Avoid unnecessary re-renders, large inline functions, and heavy loops.

‚úÖ Example:

```tsx
const MemoizedList = React.memo(UserList)
```

‚ùå Example:

```tsx
<ul>
  {users.map(user => (
    <li key={Math.random()}>{user}</li>
  ))}
</ul> // Bad: Random keys
```

---

## 7. **Styling**

- Avoid **inline styles** and **direct DOM manipulations**.
- Prefer **TailwindCSS** or **styled-components**.

‚úÖ Example:

```tsx
<div className="p-4 bg-gray-100 rounded-lg">Hello</div>
```

‚ùå Example:

```tsx
<div style={{ padding: "16px", background: "gray" }}>Hello</div>
```

---

## 8. **Comments**

- Keep comments to a minimum.
- Use comments **only for intent**, not for explaining _what the code does_.

‚úÖ Example:

```ts
// Applies seasonal discount logic
const seasonalDiscount = new PercentageDiscount(0.15)
```

‚ùå Example:

```ts
// This function applies a percentage discount
function applyDiscount(price: number, percent: number) {
  return price * (1 - percent)
}
```

---

üìå Following these rules ensures we keep our codebase **scalable, maintainable, and high-quality**.
